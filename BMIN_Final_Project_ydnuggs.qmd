---
title: "Area Deprivation Index for 2020"
subtitle: "BMIN503/EPID600 Final Project"
author: "Dana Neugut"
format: html
editor: visual
number-sections: true
embed-resources: true
---

------------------------------------------------------------------------

## Overview {#sec-overview}

Social determinants of health have a notable impact on health outcomes. The Area Deprivation Index (ADI) is a composite measure of “deprivation,” based on census block data from 1969 through 1998, that can be used in health outcomes research. In this project, we update the ADI using more recent census data.

I met with Drs. Amanda Muir and Lindsey Albenberg to gain insight on which census variables may be helpful to include in initial analyses, and to discuss analytic approaches. This project can be found at this [link to GitHub repository](https://github.com/ydnuggs/BMIN503_Final_Project).

## Introduction {#sec-introduction}

In 2002, Gopal Singh published the Area Deprivation Index (ADI), a “composite area-based deprivation index for the United States” based on census data from 1969 and 1998. It has become a tool used to examine, on an area-based scale, how social determinants of health can have an impact on outcomes such as mortality. The Area Deprivation Index uses factor score coefficients based on census data. However, neighborhoods and their sociodemographic can change over time; therefore, it is important to re-examine these calculations intermittently. Furthermore, associations can differ by states, where there are different laws and demographic factors affecting access to resources. In this project, we use recent data from the 2020 U.S. decennial census and the 2016-2020 5-year American Community Survey (ACS) to reconstruct the ADI for Pennsylvania and re-calculate the factor score coefficients. We then test whether the ADI is associated with several health outcomes, using tract level data.

The ADI is useful for health disparities research, which is an important area in all fields of research. There are several other indices that measure socioeconomic status (SES) in some way; these include the Townsend Deprivation Index, Social Disadvantage Index, and others. The ADI is one of the oldest validated indices for SES, and so we use it in this paper. Future research can include doing similar analyses for other commonly used SES indices.

## Methods {#sec-methods}

Describe the data used and general methodological approach used to address the problem described in the @sec-introduction. Subsequently, incorporate full R code necessary to retrieve and clean data, and perform analysis. Be sure to include a description of code so that others (including your future self) can understand what you are doing and why.

```{r}
# Load necessary packages
library(tidyverse)
library(gtsummary)
library(sf)
library(tidycensus)
library(ggspatial)
library(leaflet)
library(nhanesA)
library(gtsummary)
library(readxl)
library(ggbiplot)
library(psych)
library(knitr)
library(gridExtra)
library(tigris)
options(tigris_use_cache = TRUE)
options(progress_enabled = FALSE)
```

```{r}
# Use a Census API Key to perform queries with tidycensus in R, to use data from the Decennial Census and the American Community Survey (ACS).
#| eval: FALSE 
census_api_key("8d4ae400e665d714446a25ed86d77a9125c57ec6", install = TRUE, overwrite = TRUE)
```

``` t
We create a dataset with the 2020 Decennial Census variables with Demographic and Housing Characteristics (DHC). We do the same for the 2016-2020 ACS 5-year Variables. These datasets can be used to identify the variables of interest based on their decriptions in the files.
```

```{r}
# 2020 Decennial Census variables with Demographic and Housing Characteristics
decennial_2020_vars_dhc <- load_variables(
                              year = 2020, 
                              "dhc", #decennial census Demographic and Housing Characteristics file
                              cache = TRUE
                             )

# 2016-2020 ACS 5-year Variables
acs_2020_vars <- load_variables(
  year = 2020, 
  "acs5", 
  cache = TRUE
)
```

``` t
We then create datasets with each variable/s of interest. The survey datasets contain data counts and the total count surveyed, per geographic area. Therefore, we also calculate a frequency, which is the count divided by the total count, for each variable. Some variables contain sub-categories that are not of particular interest to us, so in those cases we combine multiple sub-categories to obtain the broader categories in which we are interested (for example, we combine the frequency of male single parents and of female single parents within the population, to obtain a total frequency of single parents).
```

```{r}
## educational attainment
vars_acs_education = c(
        #all = "B17003_001", #2020 Population 25+ for whom Poverty Status is Determined (ACS 5-Yr)
        pov_below_m_lesshighschool = "B17003_004", #2020 Male 25+ Below Poverty: < High School Grad (ACS 5-Yr)
        pov_below_m_highschoolgrad = "B17003_005", #2020 Male 25+ Below Poverty: High School Grad (ACS 5-Yr)
        pov_below_m_associates = "B17003_006", #2020 Male 25+ Below Poverty: Some college, associate's degree (ACS 5-Yr)
        pov_below_m_collegegrad = "B17003_007", #2020 Male 25+ Below Poverty: Bachelor/Higher (ACS 5-Yr)
        pov_below_f_lesshighschool = "B17003_009", #2020 Female 25+ Below Poverty: < High School Grad (ACS 5-Yr)
        pov_below_f_highschoolgrad = "B17003_010", #2020 Female 25+ Below Poverty: High School Grad (ACS 5-Yr)
        pov_below_f_associates = "B17003_011", #2020 Female 25+ Below Poverty: Some college, associate's degree (ACS 5-Yr)
        pov_below_f_collegegrad = "B17003_012", #2020 Female 25+ Below Poverty: Bachelor/Higher (ACS 5-Yr)
        pov_above_m_lesshighschool = "B17003_015", #2020 Male 25+ Above Poverty: < High School Grad (ACS 5-Yr)
        pov_above_m_highschoolgrad = "B17003_016", #2020 Male 25+ Above Poverty: High School Grad (ACS 5-Yr)
        pov_above_m_associates = "B17003_017", #2020 Male 25+ Above Poverty: Some college, associate's degree (ACS 5-Yr)
        pov_above_m_collegegrad = "B17003_018", #2020 Male 25+ Above Poverty: Bachelor/Higher (ACS 5-Yr)
        pov_above_f_lesshighschool = "B17003_020", #2020 Female 25+ Above Poverty: < High School Grad (ACS 5-Yr)
        pov_above_f_highschoolgrad = "B17003_021", #2020 Female 25+ Above Poverty: High School Grad (ACS 5-Yr)
        pov_above_f_associates = "B17003_022", #2020 Female 25+ Above Poverty: Some college, associate's degree (ACS 5-Yr)
        pov_above_f_collegegrad = "B17003_023" #2020 Female 25+ Above Poverty: Bachelor/Higher (ACS 5-Yr)
        )

data_acs_education = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_education,
  summary_var = "B17003_001", #creates a column w/'total' variable
  year = 2020
)

# Summarize the data
data_acs_education <- data_acs_education %>%
  mutate(category = case_when(
    variable %in% c("pov_below_m_lesshighschool", "pov_below_f_lesshighschool", "pov_above_m_lesshighschool", "pov_above_f_lesshighschool") ~ "lesshighschool",
    variable %in% c("pov_below_m_highschoolgrad", "pov_below_f_highschoolgrad", "pov_above_m_highschoolgrad", "pov_above_f_highschoolgrad") ~ "highschoolgrad",
    variable %in% c("pov_below_m_associates", "pov_below_f_associates", "pov_above_m_associates", "pov_above_f_associates") ~ "associates",
    variable %in% c("pov_below_m_collegegrad", "pov_below_f_collegegrad", "pov_above_m_collegegrad", "pov_above_f_collegegrad") ~ "collegegrad",
    TRUE ~ NA_character_  # Handle cases that do not fall into these categories
  ))

data_acs_education <- data_acs_education %>%
  group_by(GEOID, category) %>%
  summarise(
    estimate = sum(estimate, na.rm = TRUE),
    summary_est = first(summary_est),  # Assuming summary_est is the same for each group
    var_freq_education = estimate / summary_est,
    .groups = 'drop'
  )
rm(vars_acs_education)


## Population aged ≥ 25 y who did nto graduate high school
# The earlier studies did <9 years of education
data_acs_less_highschool <- data_acs_education |> filter(category == "lesshighschool")
data_acs_less_highschool <- data_acs_less_highschool %>%
  rename(var_freq_lesshighschool = var_freq_education)


## Population aged ≥ 25 y with at least an associates degree
# The earlier studies used at least a high school diploma
data_acs_associates_college <- data_acs_education %>%
  filter(category %in% c("associates", "collegegrad")) |>
  group_by(GEOID) |>
  summarise(var_freq_associates_college = sum(var_freq_education, na.rm = TRUE))

rm(data_acs_education)

## White collar jobs: Employed persons aged ≥ 16 y in white-collar occupations, defined by "management, business, science, and arts occupations" and "sales and office occupations"
vars_acs_whitecollar = c(
        #all = "C24010_001", #total included in sex by occupation for the civilian employed population 16+ years of age
        management_m = "C24010_003", #Male: Management, business, science, and arts occupations
        sales_m = "C24010_027", #Male: Sales and office occupations
        management_f = "C24010_039", #Female: Management, business, science, and arts occupations
        sales_f = "C24010_063" #Female: Sales and office occupations
        )

data_acs_whitecollar = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_whitecollar,
  summary_var = "C24010_001", #creates a column w/'total' variable
  year = 2020
)

data_acs_whitecollar <- data_acs_whitecollar %>%
  group_by(GEOID) %>%
  summarise(
    estimate = sum(estimate, na.rm = TRUE),
    summary_est = first(summary_est),  # Assuming summary_est is the same for each group
    var_freq_whitecollar = estimate / summary_est,
    .groups = 'drop'
  )
rm(vars_acs_whitecollar)


## median income
vars_acs_median_income = c(
        income_median = "B19326_001"
        )

data_acs_median_income = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_median_income,
  year = 2020
)
data_acs_median_income <- data_acs_median_income |>
  rename(var_median_income = estimate)
rm(vars_acs_median_income)


## Income disparity
# Income disparity in 1990 was defined as the log of 100 × ratio of number of households with < $10 000 income to number of households with ≥$50 000 income.
# Instead we will use the Gini coefficient.
vars_acs_gini = c(
        gini = "B19083_001" #Gini Index of income inequality (higher indicates more inequality)
        )

data_acs_gini = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_gini,
  year = 2020
)
data_acs_gini <- data_acs_gini |>
  rename(var_gini = estimate)
rm(vars_acs_gini)


## Median home value
vars_acs_home_value = c(
        home_value = "B25097_001" #median home value
        )

data_acs_home_value = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_home_value,
  year = 2020
)
data_acs_home_value <- data_acs_home_value |>
  rename(var_home_value = estimate)
rm(vars_acs_home_value)


## Median gross rent
vars_acs_median_rent = c(
        median_rent = "B25064_001" #median gross rent (dollars)
        )

data_acs_median_rent = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_median_rent,
  year = 2020
)
data_acs_median_rent <- data_acs_median_rent |>
  rename(var_median_rent = estimate)
rm(vars_acs_median_rent)


## Median monthly mortgage
# The monthly mortgage alone is not available. Instead we will use the "selected monthly owner costs." We will include units with and without mortgages (although there is data avilable if we wanted to separate by mortgage status).
vars_acs_housing_costs = c(
        housing_costs = "B25087_001" #selected monthly owner costs
        )

data_acs_housing_costs = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_housing_costs,
  year = 2020
)
data_acs_housing_costs <- data_acs_housing_costs |>
  rename(var_housing_costs = estimate)
rm(vars_acs_housing_costs)


## owner-occupied housing units (home ownership rate)
vars_dhc_homeownership = c(
        #all = "H13_001N",
        owner_occupied = "H13_002N"
        )

data_dhc_homeownership = get_decennial(
  geography = "tract",
  state = "PA",
  variables = vars_dhc_homeownership,
  summary_var = "H13_001N", #creates a column w/'total' variable
  year = 2020,
  sumfile = "dhc"
)
data_dhc_homeownership <- data_dhc_homeownership %>%
  mutate(var_freq_homeownership = ifelse(summary_value != 0, value / summary_value, NA))
rm(vars_dhc_homeownership)


## Unemployment rate
vars_acs_unemployment = c(
        #all = "C18120_002", #in the labor force
        unemployment = "C18120_006" #unemployed in the labor force
        )

data_acs_unemployment = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_unemployment,
  summary_var = "C18120_002", #creates a column w/'total' variable
  year = 2020
)
data_acs_unemployment <- data_acs_unemployment %>%
  mutate(var_freq_unemployment = ifelse(summary_est != 0, estimate / summary_est, NA))
rm(vars_acs_unemployment)


## below poverty level
vars_acs_poverty = c(
        #all = "B06012_001",
        pov_level_below100 = "B06012_002", #Below 100 percent of the poverty level
        pov_level_100to149 = "B06012_003" #100 to 149 percent of the poverty level
        )

data_acs_poverty = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_poverty,
  summary_var = "B06012_001", #creates a column w/'total' variable
  year = 2020
)
data_acs_poverty <- data_acs_poverty %>%
  mutate(var_freq_poverty = ifelse(summary_est != 0, estimate / summary_est, NA))

data_acs_poverty_level <- data_acs_poverty %>%
  filter(variable %in% "pov_level_below100")
data_acs_poverty_level <- data_acs_poverty_level %>%
  rename(var_freq_poverty_level = var_freq_poverty)

rm(vars_acs_poverty)


## Population below 150% of the poverty threshold
# Combine the categories of below 100% of the poverty threshold + 100-149% of the poverty threshold, in order to obtain a composite number of the population below 150% of the poverty threshold
data_acs_poverty_level_150 <- data_acs_poverty %>%
  mutate(category = case_when(
    variable %in% c("pov_level_below100", "pov_level_100to149") ~ "pov_level_below150",
    TRUE ~ NA_character_  # Handle cases that do not fall into these categories
  ))

data_acs_poverty_level_150 <- data_acs_poverty_level_150 %>%
  group_by(GEOID, category) %>%
  summarise(
    estimate = sum(estimate, na.rm = TRUE),
    summary_est = first(summary_est),  # Assuming summary_est is the same for each group
    var_freq_poverty_level_150 = estimate / summary_est,
    .groups = 'drop'
  )
rm(data_acs_poverty)


## Single-parent households with children aged < 18 y
vars_dhc_singleparent = c(
       #all = "P20_001N",
        singleparent_m = "P20_011N", #Male householder, no spouse or partner present, with own children under 18
        singleparent_f = "P20_017N" #Female householder, no spouse or partner present, with own children under 18
        )

data_dhc_singleparent = get_decennial(
  geography = "tract",
  state = "PA",
  variables = vars_dhc_singleparent,
  summary_var = "P20_001N", #creates a column w/'total' variable
  year = 2020,
  sumfile = "dhc"
)

# Summarize the data
data_dhc_singleparent <- data_dhc_singleparent %>%
  mutate(category = case_when(
    variable %in% c("singleparent_m", "singleparent_f") ~ "singleparent",
    TRUE ~ NA_character_  # Handle cases that do not fall into these categories
  ))

data_dhc_singleparent <- data_dhc_singleparent %>%
  group_by(GEOID, category) %>%
  summarise(
    value = sum(value, na.rm = TRUE),
    summary_value = first(summary_value),  # Assuming summary_est is the same for each group
    var_freq_singleparent = value / summary_value,
    .groups = 'drop'
  )
rm(vars_dhc_singleparent)


## no motor vehicle
vars_acs_novehicle = c(
        #all = "B08014_001", #2020 Workers Age 16+ in Households (ACS 5-Yr
        novehicle = "B08014_002" #No vehicle available
        )

data_acs_novehicle = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_novehicle,
  summary_var = "B08014_001", #creates a column w/'total' variable
  year = 2020
)
data_acs_novehicle <- data_acs_novehicle %>%
  mutate(var_freq_novehicle = ifelse(summary_est != 0, estimate / summary_est, NA))
rm(vars_acs_novehicle)


## Households without a telephone
#Are these correct? Seems like a high percentage...
vars_acs_no_telephone = c(
        #all = "B25043_001",
        no_telephone_owner = "B25043_007", #Owner occupied, no telephone service available
        no_telephone_renter = "B25043_016" #Renter occupied, no telephone service available
        )

data_acs_no_telephone = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_no_telephone,
  summary_var = "B25043_001", #creates a column w/'total' variable
  year = 2020
)

# Summarize the data
data_acs_no_telephone <- data_acs_no_telephone %>%
  mutate(category = case_when(
    variable %in% c("no_telephone_owner", "no_telephone_renter") ~ "no_telephone",
    TRUE ~ NA_character_  # Handle cases that do not fall into these categories
  ))

data_acs_no_telephone <- data_acs_no_telephone %>%
  group_by(GEOID, category) %>%
  summarise(
    estimate = sum(estimate, na.rm = TRUE),
    summary_est = first(summary_est),  # Assuming summary_est is the same for each group
    var_freq_no_telephone = estimate / summary_est,
    .groups = 'drop'
  )
rm(vars_acs_no_telephone)


## Occupied housing units without complete plumbing, % (log)
vars_acs_incomplete_plumbing = c(
        #all = "B25048_001", #plumbing facilities for occupied housing units
        incomplete_plumbing = "B25048_003" #Lacking complete plumbing facilities, for occupied housing units
        )

data_acs_incomplete_plumbing = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_incomplete_plumbing,
  summary_var = "B25048_001", #creates a column w/'total' variable
  year = 2020
)
data_acs_incomplete_plumbing <- data_acs_incomplete_plumbing %>%
  mutate(var_freq_incomplete_plumbing = ifelse(summary_est != 0, estimate / summary_est, NA))
rm(vars_acs_incomplete_plumbing)


## Households with more than 1 person per room, % (crowding)
vars_acs_overcrowding = c(
        #all = "B25014_001",
        occupance_1.01to1.50_owner = "B25014_005", #Owner occupied, 1.01 to 1.50 occupants per room
        occupance_1.51to2.00_owner = "B25014_006", #Owner occupied, 1.51 to 2.00 occupants per room
        occupance_2.01andup_owner = "B25014_007", #Owner occupied, 2.01 or more occupants per room
        occupance_1.01to1.50_renter = "B25014_011", #Renter occupied, 1.01 to 1.50 occupants per room
        occupance_1.51to2.00_renter = "B25014_012", #Renter occupied, 1.51 to 2.00 occupants per room
        occupance_2.01andup_renter = "B25014_013" #Renter occupied, 2.01 or more occupants per room
        )

data_acs_overcrowding = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_overcrowding,
  summary_var = "B25014_001", #creates a column w/'total' variable
  year = 2020
)

# Summarize the data
data_acs_overcrowding <- data_acs_overcrowding %>%
  mutate(category = case_when(
    variable %in% c("occupance_1.01to1.50_owner", "occupance_1.51to2.00_owner", "occupance_2.01andup_owner", "occupance_1.01to1.50_renter", "occupance_1.51to2.00_renter","occupance_2.01andup_renter") ~ "overcrowding",
    TRUE ~ NA_character_  # Handle cases that do not fall into these categories
  ))

data_acs_overcrowding <- data_acs_overcrowding %>%
  group_by(GEOID, category) %>%
  summarise(
    estimate = sum(estimate, na.rm = TRUE),
    summary_est = first(summary_est),  # Assuming summary_est is the same for each group
    var_freq_overcrowding = estimate / summary_est,
    .groups = 'drop'
  )
rm(vars_acs_overcrowding)
```

``` t
Extract the variable frequencies, and merge datasets to create one dataset with the 17 variables used in the ADI (as listed in PMID 12835199).
```

```{r}
## Combine variables

datasets <- list(data_acs_less_highschool, data_acs_associates_college, data_acs_incomplete_plumbing, data_acs_no_telephone, data_acs_novehicle, data_acs_overcrowding, data_acs_poverty_level, data_acs_poverty_level_150, data_acs_unemployment, data_acs_whitecollar, data_dhc_homeownership, data_dhc_singleparent, data_acs_median_income, data_acs_median_rent, data_acs_gini, data_acs_home_value, data_acs_housing_costs)

selected_datasets <- lapply(datasets, function(df) {
  df %>%
    select(GEOID, starts_with("var_"))
})

# Merge all datasets by GEOID
merged_data <- selected_datasets[[1]]  # Start with the first dataset

for (i in 2:length(selected_datasets)) {
  merged_data <- full_join(merged_data, selected_datasets[[i]], by = "GEOID")
}

```

``` t
Next we visualize the demographic variables. For the variables without a Normal distribution, we log transform them to see if that achieves Normalization.
```

```{r}
# Histograms of the data to visualize the data distributions

ggplot(data = data_acs_less_highschool, aes(var_freq_lesshighschool)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
    ggtitle("Did not complete high school")
ggplot(data = data_acs_less_highschool, aes(log(var_freq_lesshighschool))) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
    ggtitle("LOG Did not complete high school")

ggplot(data = data_acs_associates_college, aes(var_freq_associates_college)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Obtained an associate's or college degree")

ggplot(data = data_acs_incomplete_plumbing, aes(var_freq_incomplete_plumbing)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Incomplete plumbing")
ggplot(data = data_acs_incomplete_plumbing, aes(log(var_freq_incomplete_plumbing))) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("LOG Incomplete plumbing")

ggplot(data = data_acs_no_telephone, aes(var_freq_no_telephone)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("No telephone")
ggplot(data = data_acs_no_telephone, aes(log(var_freq_no_telephone))) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("LOG No telephone")

ggplot(data = data_acs_novehicle, aes(var_freq_novehicle)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("No vehicle")
ggplot(data = data_acs_novehicle, aes(log(var_freq_novehicle))) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("LOG No vehicle")

ggplot(data = data_acs_overcrowding, aes(var_freq_overcrowding)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Overcrowding (occupied hosuing units with more than 1 person per room")
ggplot(data = data_acs_overcrowding, aes(log(var_freq_overcrowding))) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("LOG Overcrowding (occupied hosuing units with more than 1 person per room")

ggplot(data = data_acs_poverty_level, aes(var_freq_poverty_level)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Families below the poverty level")
ggplot(data = data_acs_poverty_level, aes(log(var_freq_poverty_level))) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("LOG Families below the poverty level")

ggplot(data = data_acs_poverty_level_150, aes(var_freq_poverty_level_150)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Families below 150% of the poverty threshold")
ggplot(data = data_acs_poverty_level_150, aes(log(var_freq_poverty_level_150))) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("LOG Families below 150% of the poverty threshold")

ggplot(data = data_acs_unemployment, aes(var_freq_unemployment)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Unemployment")
ggplot(data = data_acs_unemployment, aes(log(var_freq_unemployment))) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("LOG Unemployment")

ggplot(data = data_acs_whitecollar, aes(var_freq_whitecollar)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Employed persons in white-collar occupations")

ggplot(data = data_dhc_homeownership, aes(var_freq_homeownership)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Home ownership")

ggplot(data = data_dhc_singleparent, aes(var_freq_singleparent)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Single-parent households")
ggplot(data = data_dhc_singleparent, aes(log(var_freq_singleparent))) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("LOG Single-parent households")

ggplot(data = data_acs_median_income, aes(var_median_income)) +
  geom_histogram(aes(y = after_stat(density)), breaks = seq(0, 80, 1)) +
  geom_density(color = "red") +
  ggtitle("Median Income")

ggplot(data = data_acs_median_rent, aes(var_median_rent)) +
  geom_histogram(aes(y = after_stat(density)), breaks = seq(0, 80, 1)) +
  geom_density(color = "red") +
  ggtitle("Median Rent")

ggplot(data = data_acs_gini, aes(var_gini)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Income disparity, measured by Gini")

ggplot(data = data_acs_home_value, aes(var_home_value)) +
  geom_histogram(aes(y = after_stat(density)), breaks = seq(0, 80, 1)) +
  geom_density(color = "red") +
  ggtitle("Home value")

ggplot(data = data_acs_housing_costs, aes(var_housing_costs)) +
  geom_histogram(aes(y = after_stat(density))) +
  geom_density(color = "red") +
  ggtitle("Housing costs")
```

``` t
Nine of the demographic variables benefited from log transformation. They are:
var_freq_lesshighschool
var_freq_incomplete_plumbing
var_freq_no_telephone
var_freq_novehicle
var_freq_overcrowding
var_freq_poverty_level
var_freq_poverty_level_150
var_freq_unemployment
var_freq_singleparent
```

``` t
We therefore update these nine variables with their log transformation.

For values of 0, we add a small constant (1e-5) before applying the log transformation. This avoids taking the log of zero, thus eliminating -Inf. We do this instead of replacing the values with "NA" because the zeroes are real, and we do not want to lose them from our dataset.
```

```{r}
# List of variables to log-transform
variables_to_log <- c(
  "var_freq_lesshighschool",
  "var_freq_incomplete_plumbing",
  "var_freq_no_telephone",
  "var_freq_novehicle",
  "var_freq_overcrowding",
  "var_freq_poverty_level",
  "var_freq_poverty_level_150",
  "var_freq_unemployment",
  "var_freq_singleparent"
)

# Apply log transformation and rename variables
merged_data <- merged_data %>%
  mutate(across(
    all_of(variables_to_log), 
    ~ log(. + 1e-5), 
    .names = "{.col}_log"
  ))
```

``` t
Import CDC PLACES data, which contains health outcomes data.
```

```{r}
# The data is taken from the following URL. Unfortunately the code to import the data is not working properly, so we downloaded it as a CSV file and here import the file.
# https://data.cdc.gov/download/PLACES-Local-Data-for-Better-Health-Census-Tract-D/excel/PLACES-Local-Data-for-Better-Health-Census-Tract-D.xlsx

data_places = read_csv("PLACES__Local_Data_for_Better_Health__Census_Tract_Data_2024_release_20241027.csv")

# rename variable "LocationName" to "GEOID" to be consistent with census data
data_places <- data_places %>% 
    rename("GEOID" = "LocationName")

# Filter to include only Pennsylvania
data_places=data_places |> filter(StateAbbr=="PA")
```

``` t
Create a dataset of several important health outcomes. Of note, mortality data is not included, as it is not available via PLACES, and special permission is required for access.
The health outcomes data is expressed as a frequency.
```

```{r}
# Filter to include only the obesity data
data_places_obesity=data_places |> filter(Measure=="Obesity among adults") |> select(GEOID, Data_Value) |> rename(Rate_Obesity = Data_Value)

# Filter to include stroke data
data_places_stroke=data_places |> filter(Measure=="Stroke among adults") |> select(GEOID, Data_Value) |> rename(Rate_Stroke = Data_Value)

# Filter to include coronary heart disease data
data_places_heart=data_places |> filter(Measure=="Coronary heart disease among adults") |> select(GEOID, Data_Value) |> rename(Rate_Heart = Data_Value)

# Filter to include disability data
data_places_disability=data_places |> filter(Measure=="Any disability among adults") |> select(GEOID, Data_Value) |> rename(Rate_Disability = Data_Value)

# Filter to include fair or poor self-rated health status
data_places_healthrating=data_places |> filter(Measure=="Fair or poor self-rated health status among adults") |> select(GEOID, Data_Value) |> rename(Rate_Healthrating = Data_Value)

merged_outcomes = data_places_obesity |>
  left_join(data_places_stroke, by = "GEOID") |>
  left_join(data_places_heart, by = "GEOID") |>
  left_join(data_places_disability, by = "GEOID") |>
  left_join(data_places_healthrating, by = "GEOID")

## We check if there are values in the demographic data that are not within the health outcomes data, or vice versa.
length(setdiff(merged_data$GEOID, merged_outcomes$GEOID)) #There are 38 rows in the demographic data that are not in the health outcomes data.

# We check the data for the missing tracts. We sample a few of them.
setdiff(merged_data$GEOID, merged_outcomes$GEOID)
merged_data %>% filter(GEOID == 42101036901) #an example of one we checked
# They seem to be empty aside from the GEOID in the demographic dataset. It seems that for whatever reason, this tract does not have any demographic data and it is okay to remove them from the analyses, and use only those with demographic and outcomes data.

```

``` t
First we check how many tracts are included in our dataset with both demographic and health outcomes data.
```

```{r}
# Number of tracts with demographic data
num_tracts_demographic <- merged_data |> distinct(GEOID) |> nrow()

# Number of tracts with health outcomes data
num_tracts_health_outcomes <- merged_outcomes |> distinct(GEOID) |> nrow()

# Number of tracts with both demographic and health outcomes data
num_tracts_both <- merged_outcomes |> inner_join(merged_data, by = "GEOID") |> distinct(GEOID) |> nrow()

# Create a summary table
summary_table <- data.frame(
  Category = c("# Tracts with Demographic Data", "# Tracts with Health Outcomes Data", "# Tracts with Both Demographic and Health Outcomes Data"),
  Number_of_Tracts = c(num_tracts_demographic, num_tracts_health_outcomes, num_tracts_both)
)

# Print the summary table
kable(summary_table, caption = "Summary of Tracts with Data", align = c("l", "r"), digits = 0)
```

``` t
Next we check our data missingness.
```

```{r}
# List of demographic variables
vars_demographic <- c(
  "var_freq_lesshighschool_log", 
  "var_freq_associates_college", 
  "var_freq_incomplete_plumbing_log", 
  "var_freq_no_telephone_log", 
  "var_freq_novehicle_log", 
  "var_freq_overcrowding_log", 
  "var_freq_poverty_level_log", 
  "var_freq_poverty_level_150_log", 
  "var_freq_unemployment_log", 
  "var_freq_whitecollar", 
  "var_freq_homeownership", 
  "var_freq_singleparent_log", 
  "var_median_income", 
  "var_median_rent", 
  "var_gini", 
  "var_home_value", 
  "var_housing_costs"
)

# Subset the dataframe to include only the columns you're interested in
merged_data_subset <- merged_data[, vars_demographic]

# Calculate the missingness for each variable
missingness_table_demographics <- data.frame(
  Variable = colnames(merged_data_subset),  # List of variables
  Missingness = sapply(colnames(merged_data_subset), function(var) {
    # Calculate the percentage of missing values for each variable
    mean(is.na(merged_data_subset[[var]]), na.rm = TRUE) * 100
  })
)

# Reset row names to avoid duplication issues in kable
rownames(missingness_table_demographics) <- NULL

# Print the table using kable to make it more presentable
missingness_table_demographics %>%
  kable(col.names = c("Variable", "Missing Data Count"),
        caption = "Missing Data Count for Demographic Variables",
        align = c("l", "r"),
        format = "markdown")

# List of outcomes variables
vars_outcomes <- c(
  "Rate_Obesity", 
  "Rate_Stroke", 
  "Rate_Heart", 
  "Rate_Disability", 
  "Rate_Healthrating"
)

# Subset the dataframe to include only the columns you're interested in
merged_outcomes_subset <- merged_outcomes[, vars_outcomes]

# Calculate the missingness for each variable
missingness_table_outcomes <- data.frame(
  Variable = colnames(merged_outcomes_subset),  # List of variables
  Missingness = sapply(colnames(merged_outcomes_subset), function(var) {
    # Calculate the percentage of missing values for each variable
    mean(is.na(merged_outcomes_subset[[var]]), na.rm = TRUE) * 100
  })
)

# Reset row names to avoid duplication issues in kable
rownames(missingness_table_outcomes) <- NULL

# Print the table using kable to make it more presentable
missingness_table_outcomes %>%
  kable(col.names = c("Variable", "Missing Data Count"),
        caption = "Missing Data Count for Health Outcomes Variables",
        align = c("l", "r"),
        format = "markdown")
```

## Results {#sec-results}

Describe your results and include relevant tables, plots, and code/comments used to obtain them. You may refer to the @sec-methods as needed. End with a brief conclusion of your findings related to the question you set out to address. You can include references if you'd like, but this is not required.

``` t
First we observe basic summary statistics for the demographic variables of interest, as well as the five health outcomes we will be examining: obesity, stroke, coronary heart disease, disability, and self-rated health.
```

```{r}
# Create a summary table for the demographic variables
summary_table_demographics <- merged_data_subset %>%
  summarise(across(everything(), 
                   list(mean = ~mean(. , na.rm = TRUE), 
                        sd = ~sd(. , na.rm = TRUE), 
                        missing = ~sum(is.na(.))),
                   .names = "{.col}_{.fn}")) %>%
  pivot_longer(cols = everything(), 
               names_to = c("Characteristic", "Statistic"),
               names_pattern = "(.*)_(.*)") %>%
  pivot_wider(names_from = Statistic, values_from = value) %>%
  mutate(
    # Round mean and sd to 2 decimal places
    `Average (Standard Deviation), N=3446` = paste0(round(mean, 2), " (", round(sd, 2), ")"),
    Missingness = missing
  ) %>%
  select(Characteristic, `Average (Standard Deviation), N=3446`, Missingness)

# View the summary table
summary_table_demographics


# Create a summary table for the outcomes variables
summary_table_outcomes <- merged_outcomes_subset %>%
  summarise(across(everything(), 
                   list(mean = ~mean(. , na.rm = TRUE), 
                        sd = ~sd(. , na.rm = TRUE), 
                        missing = ~sum(is.na(.))),
                   .names = "{.col}_{.fn}")) %>%
  pivot_longer(cols = everything(), 
               names_to = c("Characteristic", "Statistic"),
               names_pattern = "(.*)_(.*)") %>%
  pivot_wider(names_from = Statistic, values_from = value) %>%
  mutate(
    # Round mean and sd to 2 decimal places
    `Average (Standard Deviation), N=3446` = paste0(round(mean, 2), " (", round(sd, 2), ")"),
    Missingness = missing
  ) %>%
  select(Characteristic, `Average (Standard Deviation), N=3446`, Missingness)

# View the summary table
summary_table_outcomes

```

``` t
Next we examine the distributions of the health outcomes data.
```

```{r}
# Disability
plot_disability = ggplot(merged_outcomes, aes(x = Rate_Disability)) + 
  geom_histogram(binwidth = 5, fill = "skyblue", color = "black", alpha = 0.7) +
  labs(title = "Disability Data", 
       x = "Disability Percentage", 
       y = "Frequency") +
  theme_minimal()

# Health Self-Rating
plot_healthrating = ggplot(merged_outcomes, aes(x = Rate_Healthrating)) + 
  geom_histogram(binwidth = 5, fill = "skyblue", color = "black", alpha = 0.7) +
  labs(title = "Health Self-Rating Data", 
       x = "Health Self-Rating Percentage", 
       y = "Frequency") +
  theme_minimal()

# Coronary Heart Disease
plot_heart = ggplot(merged_outcomes, aes(x = Rate_Heart)) + 
  geom_histogram(binwidth = 5, fill = "skyblue", color = "black", alpha = 0.7) +
  labs(title = "Coronary Heart Disease Data", 
       x = "Coronary Heart Disease Percentage", 
       y = "Frequency") +
  theme_minimal()

# Obesity
plot_obesity = ggplot(merged_outcomes, aes(x = Rate_Obesity)) + 
  geom_histogram(binwidth = 5, fill = "skyblue", color = "black", alpha = 0.7) +
  labs(title = "Obesity Data", 
       x = "Obesity Percentage", 
       y = "Frequency") +
  theme_minimal()

# Stroke
plot_stroke = ggplot(merged_outcomes, aes(x = Rate_Stroke)) + 
  geom_histogram(binwidth = 5, fill = "skyblue", color = "black", alpha = 0.7) +
  labs(title = "Stroke Data", 
       x = "Stroke Percentage", 
       y = "Frequency") +
  theme_minimal()

# Combine the plots into one graphic
grid.arrange(plot_disability, plot_healthrating, plot_heart, plot_obesity, plot_stroke, ncol = 2)

```

``` t
Next we create choropleth maps.
```

```{r}
# We start by creating a base map of Pennsylvania.
pa.tracts = tracts(cb = TRUE, resolution = "500k",year="2020")

pa.tracts = pa.tracts |>  filter(STATEFP == 42)

ggplot(data = st_simplify(pa.tracts, dTolerance = 1e3)) +
  geom_sf() +
  ggtitle("Pennsylvania Tracts")
```

``` t
Next we create chloropleth maps for each of the health ourcomes variables. These maps help us visualize the distribution of the health outcomes data across Pennsylvania tracts.
```

```{r}
merged_data_outcomes <- pa.tracts %>%
  inner_join(merged_outcomes, by = c("GEOID" = "GEOID"))

# Obesity
ggplot(data = merged_data_outcomes) +
  geom_sf(aes(fill = Rate_Obesity), color = "white", size = 0.2) + 
  scale_fill_viridis_c(option = "C") +  # You can change this to a different color scale
  labs(title = "Obesity Rate by Census Tract",
       fill = "Obesity %") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Stroke
ggplot(data = merged_data_outcomes) +
  geom_sf(aes(fill = Rate_Stroke), color = "white", size = 0.2) + 
  scale_fill_viridis_c(option = "C") +
  labs(title = "Stroke Rate by Census Tract",
       fill = "Stroke %") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Coronary Heart Disease
ggplot(data = merged_data_outcomes) +
  geom_sf(aes(fill = Rate_Heart), color = "white", size = 0.2) + 
  scale_fill_viridis_c(option = "C") +
  labs(title = "Coronary Heart Disease Rate by Census Tract",
       fill = "Coronary Heart Disease %") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Disability
ggplot(data = merged_data_outcomes) +
  geom_sf(aes(fill = Rate_Disability), color = "white", size = 0.2) + 
  scale_fill_viridis_c(option = "C") +
  labs(title = "Disability Rate by Census Tract",
       fill = "Disability %") +
  theme_minimal() +
  theme(legend.position = "bottom")

# Self-rated health
ggplot(data = merged_data_outcomes) +
  geom_sf(aes(fill = Rate_Healthrating), color = "white", size = 0.2) + 
  scale_fill_viridis_c(option = "C") +
  labs(title = "Health Rating Average Rate by Census Tract",
       fill = "Health Rating %") +
  theme_minimal() +
  theme(legend.position = "bottom")

```

``` t
Perform factor analysis.
```

```{r}
# We have to omit NA values before performing factor analysis
merged_data_subset = merged_data[, c("GEOID",vars_demographic)] #include GEOID for now
merged_data_subset_clean <- na.omit(merged_data_subset) #remove NAs

# Perform factor analysis (1-factor solution)
fa_result <- fa(merged_data_subset_clean[,2:18], nfactors = 1, rotate = "varimax")

# Check the factor loadings
fa_result$loadings

# Calculate factor scores for each geographic tract based on the factor analysis
factor_scores <- factor.scores(merged_data_subset_clean[,2:18], fa_result) #Each row corresponds to a geographic tract, and each column corresponds to a factor score, based on the factors extracted in the factor analysis.
```

``` t
We use the factor loadings to compute the ADI for each tract.
```

```{r}
adi_scores <- factor_scores$scores[, 1]  # Take the first factor score as the ADI score

# Add the ADI score to the dataset
merged_data_subset_clean$ADI <- adi_scores
```

``` t
Plot a map of the ADI in Pennsylvania tracts.
```

```{r}
merged_data_subset_clean_map <- pa.tracts |>
  inner_join(merged_data_subset_clean, by = "GEOID")

ggplot(data = merged_data_subset_clean_map) +
  geom_sf(aes(fill = ADI), color = "white", size = 0.2) + 
  scale_fill_viridis_c(option = "C") +
  labs(title = "Area Deprivation Index by Census Tract",
       fill = "ADI") +
  theme_minimal() +
  theme(legend.position = "bottom")
```

``` t
We test whether the ADI is associated with health outcomes.
```

```{r}
# Combine predictor and outcomes data.
merged_data_all = merged_data_subset_clean |>
  inner_join(merged_outcomes, by = "GEOID")

# Scatter plots
plot_disability = merged_data_all |> 
  ggplot(aes(x = ADI, y = Rate_Disability)) +
  geom_point(color = "darkseagreen3") +
  theme_bw()

plot_healthrating = merged_data_all |> 
  ggplot(aes(x = ADI, y = Rate_Healthrating)) +
  geom_point(color = "darkseagreen3") +
  theme_bw()

plot_heart = merged_data_all |> 
  ggplot(aes(x = ADI, y = Rate_Heart)) +
  geom_point(color = "darkseagreen3") +
  theme_bw()

plot_obesity = merged_data_all |> 
  ggplot(aes(x = ADI, y = Rate_Obesity)) +
  geom_point(color = "darkseagreen3") +
  theme_bw()

plot_stroke = merged_data_all |> 
  ggplot(aes(x = ADI, y = Rate_Stroke)) +
  geom_point(color = "darkseagreen3") +
  theme_bw()

# Combine the plots into one graphic
grid.arrange(plot_disability, plot_healthrating, plot_heart, plot_obesity, plot_stroke, ncol = 2)
```

``` t
There do seem to be associations, so we quantify them using the Pearson correlation.
```

```{r}
# Calculate correlations
cor_results <- tibble(
  Outcome = c("Rate_Disability", "Rate_Healthrating", "Rate_Heart", "Rate_Obesity", "Rate_Stroke"),
  Correlation = c(
    cor(merged_data_all$ADI, merged_data_all$Rate_Disability, use = "complete.obs"),
    cor(merged_data_all$ADI, merged_data_all$Rate_Healthrating, use = "complete.obs"),
    cor(merged_data_all$ADI, merged_data_all$Rate_Heart, use = "complete.obs"),
    cor(merged_data_all$ADI, merged_data_all$Rate_Obesity, use = "complete.obs"),
    cor(merged_data_all$ADI, merged_data_all$Rate_Stroke, use = "complete.obs")
  )
)

# View the results
cor_results

```

## Conclusion

This the conclusion. The @sec-results can be invoked here.

```{r}
# Other variables that may be of interest to study and potentially incorporate

## race
vars_dhc_race = c(
        #all = "P3_001N",
        white = "P3_002N",
        baa = "P3_003N",
        amin = "P3_004N",
        asian = "P3_005N",
        nhopi = "P3_006N",
        other = "P3_007N",
        multi = "P3_008N"
       )

data_dhc_race = get_decennial(
  geography = "tract",
  state = "PA",
  variables = vars_dhc_race,
  summary_var = "P3_001N", #creates a column w/'total' variable
  year = 2020,
  sumfile = "dhc"
)
#create a column with frequency
data_dhc_race <- data_dhc_race %>%
  mutate(var_freq_race = ifelse(summary_value != 0, value / summary_value, NA))
#remove variable list
rm(vars_dhc_race)

## ethnicity
vars_dhc_ethnicity = c(
        #all = "P4_001N",
        nothisp = "P4_002N", #Not Hispanic or Latino
        hisp = "P4_003N" #Hispanic or Latino
       )

data_dhc_ethnicity = get_decennial(
  geography = "tract",
  state = "PA",
  variables = vars_dhc_ethnicity,
  summary_var = "P4_001N", #creates a column w/'total' variable
  year = 2020,
  sumfile = "dhc"
)
data_dhc_ethnicity <- data_dhc_ethnicity %>%
  mutate(var_freq_ethnicity = ifelse(summary_value != 0, value / summary_value, NA))
rm(vars_dhc_ethnicity)

## urban/rural
vars_dhc_urban_p = c(
        #all = "P2_001N",
        urban = "P2_002N",
        rural = "P2_003N",
        urbanrural_undefined = "P2_004N" #Not defined for this file
       )

data_dhc_urban_p = get_decennial(
  geography = "tract",
  state = "PA",
  variables = vars_dhc_urban_p,
  summary_var = "P2_001N", #creates a column w/'total' variable
  year = 2020,
  sumfile = "dhc"
)
data_dhc_urban_p <- data_dhc_urban_p %>%
  mutate(var_freq_urban = ifelse(summary_value != 0, value / summary_value, NA))
rm(vars_dhc_urban_p)

## housing units occupied
vars_dhc_housing_occ = c(
        #all = "H3_001N",
        housing_occupied = "H3_002N",
        housing_vacant = "H3_003N"
        )

data_dhc_housing_occ = get_decennial(
  geography = "tract",
  state = "PA",
  variables = vars_dhc_housing_occ,
  summary_var = "H3_001N", #creates a column w/'total' variable
  year = 2020,
  sumfile = "dhc"
)
data_dhc_housing_occ <- data_dhc_housing_occ %>%
  mutate(var_freq_housing_occ = ifelse(summary_value != 0, value / summary_value, NA))
rm(vars_dhc_housing_occ)

## household type
#NOTE: A household that has at least one member of the household related to the householder by birth, marriage, or adoption is a "Family household." "Nonfamily households" consist of people living alone and households which do not have any members related to the householder.
vars_dhc_household_type = c(
        #all = "P16_001N",
        married = "P16_003N", #Family households: Married couple family
        householder_male = "P16_005N", #Family households: Male householder, no spouse present
        householder_female = "P16_006N", #Family households: Female householder, no spouse present
        householder_alone = "P16_008N", #Nonfamily households: Householder living alone
        householder_not_alone = "P16_009N" #Nonfamily households: Householder not living alone
       )

data_dhc_household_type = get_decennial(
  geography = "tract",
  state = "PA",
  variables = vars_dhc_household_type,
  summary_var = "P16_001N", #creates a column w/'total' variable
  year = 2020,
  sumfile = "dhc"
)
data_dhc_household_type <- data_dhc_household_type %>%
  mutate(var_freq_household_type = ifelse(summary_value != 0, value / summary_value, NA))
rm(vars_dhc_household_type)

## household size
vars_dhc_household_size = c(
       #all = "H9_001N",
        household_one = "H9_002N", #1-person household
        household_two = "H9_003N", #2-person household
        household_three = "H9_004N", #3-person household
        household_four = "H9_005N", #4-person household
        household_five = "H9_006N", #5-person household
        household_six = "H9_007N", #6-person household
        household_seven = "H9_008N" #7-person household
        )

data_dhc_household_size = get_decennial(
  geography = "tract",
  state = "PA",
  variables = vars_dhc_household_size,
  summary_var = "H9_001N", #creates a column w/'total' variable
  year = 2020,
  sumfile = "dhc"
)
data_dhc_household_size <- data_dhc_household_size %>%
  mutate(var_freq_household_size = ifelse(summary_value != 0, value / summary_value, NA))
rm(vars_dhc_household_size)


## median age
vars_dhc_median_age = c(
        age_median = "P13_001N"
        )

data_dhc_median_age = get_decennial(
  geography = "tract",
  state = "PA",
  variables = vars_dhc_median_age,
  year = 2020,
  sumfile = "dhc"
)
rm(vars_dhc_median_age)


## income
vars_acs_income = c(
        #all = "B19001_001", #HOUSEHOLD INCOME IN THE PAST 12 MONTHS (IN 2020 INFLATION-ADJUSTED DOLLARS)
        income_under10k = "B19001_002", #Less than $10,000
        income_10_add5 = "B19001_003", #$10,000 to $14,999
        income_15_add5 = "B19001_004", #$15,000 to $19,999
        income_20_add5 = "B19001_005", #$20,000 to $24,999
        income_25_add5 = "B19001_006", #$25,000 to $29,999
        income_30_add5 = "B19001_007", #$30,000 to $34,999
        income_35_add5 = "B19001_008", #$35,000 to $39,999
        income_40_add5 = "B19001_009", #$40,000 to $44,999
        income_45_add5 = "B19001_010", #$45,000 to $49,999
        income_50_add10 = "B19001_011", #$50,000 to $59,999
        income_60_add15 = "B19001_012", #$60,000 to $74,999
        income_75_add25 = "B19001_013", #$75,000 to $99,999
        income_100_add25 = "B19001_014", #$100,000 to $124,999
        income_125_add25 = "B19001_015", #$125,000 to $149,999
        income_150_add50 = "B19001_016", #$150,000 to $199,999
        income_above200 = "B19001_017" #$200,000 or more
        )

data_acs_income = get_acs(
  geography = "tract",
  state = "PA",
  variables = vars_acs_income,
  summary_var = "B19001_001", #creates a column w/'total' variable
  year = 2020
)

# Summarize the data
data_acs_income <- data_acs_income %>%
  mutate(category = case_when(
    variable %in% "income_under10k" ~ "income_under10k",
    variable %in% c("income_50_add10", "income_60_add15", "income_75_add25", "income_100_add25" , "income_125_add25", "income_150_add50", "income_above200") ~ "income50kandup",
    TRUE ~ NA_character_  # Handle cases that do not fall into these categories
  ))

data_acs_income_combined <- data_acs_income %>%
  group_by(GEOID, category) %>%
  summarise(
    estimate = sum(estimate, na.rm = TRUE),
    summary_est = first(summary_est),  # Assuming summary_est is the same for each group
    var_freq_income = estimate / summary_est,
    .groups = 'drop'
  )
rm(vars_acs_income)
```

```{r}
### WHY DOES THIS NOT WORK?

# Define the URL of the Excel file
url_places <- "https://data.cdc.gov/download/PLACES-Local-Data-for-Better-Health-Census-Tract-D/excel/PLACES-Local-Data-for-Better-Health-Census-Tract-D.xlsx"
#url_places <- "https://data.cdc.gov/500-Cities-Places/PLACES-Local-Data-for-Better-Health-Census-Tract-D/cwsq-ngmh/about_data"

# Define a temporary file path
temp_file <- tempfile(fileext = ".xlsx")

# Download the Excel file
download.file(url_places, temp_file, mode = "wb")

# Read the Excel file
data_places <- read_excel(temp_file)

# View the first few rows of the data
print(head(data_places))
```

## References

``` t
Centers for Disease Control and Prevention. (2024). PLACES: Local Data for Better Health, Census Tract Data 2024 release mortality. U.S. Department of Health & Human Services. https://data.cdc.gov/500-Cities-Places/PLACES-Local-Data-for-Better-Health-Census-Tract-D/cwsq-ngmh/data_preview. Accessed November 21, 2024.

Kind AJ, Jencks S, Brock J, Yu M, Bartels C, Ehlenbach W, Greenberg C, Smith M. Neighborhood socioeconomic disadvantage and 30-day rehospitalization: a retrospective cohort study. Ann Intern Med. 2014 Dec 2;161(11):765-74. doi: 10.7326/M13-2946. PMID: 25437404; PMCID: PMC4251560.

Singh GK. Area deprivation and widening inequalities in US mortality, 1969-1998. Am J Public Health. 2003 Jul;93(7):1137-43. doi: 10.2105/ajph.93.7.1137. PMID: 12835199; PMCID: PMC1447923.

Singh GK, Siahpush M. Increasing inequalities in all-cause and cardiovascular mortality among US adults aged 25-64 years by area socioeconomic status, 1969-1998. Int J Epidemiol. 2002 Jun;31(3):600-13. doi: 10.1093/ije/31.3.600. PMID: 12055162.
```

## Supplement

These are some additional calculations and graphics that were used in the data preparation and cleaning.

``` t
Perform Principal Component Analysis (PCA).
```

```{r}
# Perform PCA
merged.pca <- prcomp(merged_data_subset_clean, scale = TRUE)
print(merged.pca) #Displays std deviations of PCs and their loadings (i.e. coefficients)

# Check proportion of variance explained by PCs
summary(merged.pca)

# Create a screeplot
ggscreeplot(merged.pca)
```

``` t
TO DO:
- change from PA-specific to include entire US, in line with ADI
- and/or can do both, and see if ADI calculations differ by state using a few
```
